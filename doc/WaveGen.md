
# WaveGen parameters

Here's an example of a "wave" component represented in YAML:
```
osc1:
    midi: note-on   # send this component note ON messages
    detune: -12
    offset: 7
    type: wave
    shape: square
    out: main
```

The following parameters can be used for wave generators. Only certain ones may apply, depending on the wave shape you have chosen. For example, **noise** does not care about **offset** or **detune**.

 - **shape** - For a wave, the wave form. Following are the key words (which must be exact) for specifying the different wave forms:
    - **sine** - pure sine wave
    - **square** - with 50% duty cycle
    - **pwm** - a square wave with pulse width modulation. In other words, you can hook it up to an LFO to modulate the duty cycle.  
    - **saw** - with a linear rise and a linear fall, with a 50% duty cycle
    - **ramp-up** - a linear rise and instantaneous fall (like a saw with a 100% duty cycle)
    - **ramp-down** - a linear fall and instantaneous rise (a saw with a 0% duty cycle)
    - **harmonic** - allows you to combine sine waves at harmonic intervals. Generally more efficient than the anharmonic WaveGen, because it creates a snapshot of a single cycle at the outset and then plays back from a wavetable. There are some presets you can use. See "more on harmonic waves" below.
    - **anharmonic** - allows you to combine sine waves at whatever intervals you want. Because they are not harmonic, they will have to be computed on the fly.
    - **noise** - a signal generated by the random number function. Note that a WaveGen with this wave shape has no reason to listen to the note frequency. To alter the sound, you'll want a filter.
    - **trace-linear** - Traces the amount of linear modulation this oscillator is experiencing as the maximum modulation over a one-second time frame. For FM introspection. See [Frequency Modulatiom](FrequencyModulation.md) for more. 
    - **trace-relative** - Traces the modulated frequency of another oscillator relative to the base frequency of this oscillator, in semitones. Typically, the other oscillator will be modulated by a MIDI controller. For FM introspection. See [Frequency Modulatiom](FrequencyModulation.md) for more. 
 
 - **detune** - cents relative to the base frequency. 100 cents equals a half step, so adding detune plus offset you can choose any frequency relative to the base. May be positive or negative.
 
 - **offset** - number of half steps to offset the frequency from the base. -12 is down an octave. 6 is a tritone. Dust off your music theory books! 
 
  - **freq** - mostly for LFO's. Overrides the MIDI key frequency, whether or not the WaveGen receives note-on messages. For an LFO, you probably also want to say `signed: false`  though signed values can produce interesting effects.
  
  - **level-scale** - an optional value by which to scale the output. The output value is multiplied by level-scale, so the default is "1."  Can help you control extra-weak or extra-strong signals. 
  
  - **level-override** - hardwires the "amplitude" to this value. If the amplitude is 10, the values output will range from -10 to 10, unless the "signed" flag is true, in which case they will vary from 0 to 20. 
  
  - **signed** - {true|false} default true. If set to false, the WaveGen will only output values above zero, by adding the amplitude to each point. So the wave will have the same shape and size, but be shifted above the X axis. 
    
  - **mod-percent** - The percentage of modulation for a PWM wave. See `pwm.yaml` in the resources directory for examples. PWM stands for "Pulse Width Modulation" and refers to changing the duty cycle of a square wave, which gives a kind of combing effect.
  
  - **input-log** - for analog-style frequency modulation, e.g. for vibrato. Requires two sub-properties: semitones and amp. Amp is the maximum (integer) amplitude expected from the modulator, specified as **level-override** from a WaveGen, or **out-level-amp** from an Envelope to correspond with **out-level**. 

```  
    input-log:
      semitones: 2.1
      amp: 1000
```
To reach this input, in the modulating component's properties, say 

    out: <component-name>.log
 
 - **input-linear** - for DX7-style FM. Its parameters are the amp (see **input-log**) and the frequency spread.  For example, if the frequency is given as 200, the modulation will be between (_<note-freq>_ - 200) and (_<note-freq>_ + 200).
 
```
  input-linear:
    frequency: 200
    amp: 1000
``` 
To reach this input, in the modulating component's properties, say 

    out: <component-name>.linear
 
You'll find examples in the program/test-fm directory. To load patches in subdirectories (like this one is), be sure to say **-all-patches** on the command line. 
  
## amplitude

The exact amplitude is the result of an equation that may change. To override this formula, use the **level-override** property to set a fixed (integer) amplitude.  

"Amplitude" in this context means the distance on either side of the X axis. For example, if the amplitude is 10, the wave will vary from -10 to 10, unless it's marked as "signed," in which case it will vary from 0 to 20. 

If you don't use **level-override**, the amplitude currently looks like this:

**ampBase** x **pitchScale** x **velocityMultiplier** x **levelScale**

 - **ampBase** - presently set to 1024. This could change.  
 - **pitchScale** - a complex formula, but by default the amplitude decreases by .1 per octave going up.  For example if C3 has a level of 1, pitchScale will look like this:
     - C1 - 1.2
     - C2 - 1.1
     - C3 - 1
     - C4 - .9
     - C5 - .8

    and so on.  Eventually there will be a way to adjust this.    
 - **velocityMultiplier** - currently can be affected by the **velocity-base** and **velocity-amount** parameters, though this may change. The way it works now is to compute a multiplier between 0 and 1, as follows:
 ```
        velocityMultiplier = min(1.0,
            velocityBase + velocityAmount * vel / 128.0 )            
 ```
The variables in the equation are as follows:
- **vel** will be the MIDI velocity, between 0 and 127, so dividing by 128 will give a number from 0 to (almost) 1. This comes in from the Note-ON message.
- **velocity-base** - use this property to specify a value from 1 to 100, which (for the above equation) will be divided by 100 to arrive at a value between 0 and 1 for **velocityBase**
- **velocity-amount** - can be from 1 to 200, but again is a percentage. So it will be divided by 100 to arrive at **velocityAmount** in the formula above.  
     
  
  
 ## more on harmonic waves 
    
  - **preset** - for a **harmonic** wave ONLY, there are a few presets you can use as an alternative to the **waves** setting that follows. Use one or the other. You can't use both.
  
    Current harmonic wave presets are: 
    - mellow
    - odd
    - bell
    - organ
  
  - **waves** - For the harmonic or anharmonic waves, the composition of the waves is given as a series of integer pairs: 
      - frequency multiplier - we multiply the base frequency by this number to arrive at the frequency of the sine wave you want to add. 
      
      - divisor - we divide the amplitude by this number to get the amplitude of your "harmonic" (or anharmonic as the case may be)

      Note that for harmonic waves, you may specify non-integer values, but since the wave will be a snapshot of the single cycle (and hence harmonic) you will not hear an anharmonic tone, but rather a kind of buzzing. It can yield possibly useful results, so I left it that way.
       
      If you want a genuine anharmonic voice, use the "anharmonic" wave shape. Note that the anharmonic WaveGen is much less efficient than the harmonic one, as it creates all of the waves on the fly. The harmonic WaveGen takes a snapshot of a single wave and uses it as a wavetable. (which is, incidentally, also how a plain sine wave works). 
      
    Here are the settings that the "octave organ" uses (a harmonic WaveGen)   
```
          waves:
            - 1 1
            - 2 2
            - 4 4
            - 8 8
            - 16 16
```



 